<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[周期性学习率(Cyclical Learning Rate)技术]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%91%A8%E6%9C%9F%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%8E%87%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[本文介绍神经网络训练中的周期性学习率技术。 Introduction学习率(learning_rate, LR)是神经网络训练过程中最重要的超参数之一，它对于快速、高效地训练神经网络至关重要。简单来说，LR决定了我们当前的权重参数朝着降低损失的方向上改变多少。 1new_weight = exsiting_weight - learning_rate * gradient Fig.: A simple neural network where the w’s and b’s are to be learnt (Img Credit: Matt Mazur) 这看上去很简单。但是正如许多研究显示的那样，单单通过提升这一步就会对我们的训练产生深远的影响，并且尚有很大的优化空间。 本文介绍了一种叫做周期性学习率（CLR）的技术，它是一种非常新的、简单的想法，用来设置和控制训练过程中LR的大小。该技术在jeremyphoward今年的fast.ai course课程中提及过。 Motivation神经网络用来完成某项任务需要对大量参数进行训练。参数训练意味着寻找合适的一些参数，使得在每个batch训练完成后损失（loss）达到最小。 通常来说，有两种广泛使用的方法用来设置训练过程中的LR。 One LR for all parameters一个典型的例子是SGD， 在训练开始时设置一个LR常量，并且设定一个LR衰减策略（如step，exponential等）。这个单一的LR用来更新所有的参数。在每个epochs中，LR按预先设定随时间逐渐衰减，当我们临近最小损失时， 通过衰减可以减缓更新，以防止我们越过最小值。 Fig. Effect of various learning rates on convergence (Img Credit: cs231n) 该方法存在如下挑战(refer)： 难以选择初始的LR达到想要的效果（如上图所示）； LR衰减策略同样难以设定，他们很难自适应动态变化的数据； 所有的参数使用相同的LR进行更新，而这些参数可能学习速率不完全相同； 很容易陷入马鞍点不能自拔（下面会阐述） Adaptive LR for each parameter一些改进的优化器如AdaGrad, AdaDelta, RMSprop and Adam 很大程度上缓解了上述困难，方法是对每个参数采用不同的自适应学习率。比如AdaDelta，它的更新机制甚至不需要我们主动设置默认的学习率。 Fig: Animation comparing optimization algorithms (Img Credit: Alec Radford) Cycling Learning RateCLR是Leslie Smith于2015年提出的。这是一种调节LR的方法，在该方法中，设定一个LR上限和下限，LR的值在上限和下限的区间里周期性地变化。看上去，LCR似乎是自适应LR技术和SGD的竞争者，事实上，CLR技术是可以和上述提到的改进的优化器一起使用来进行参数更新的。 而在计算上，CLR比上述提到的改进的优化器更容易实现，正如文献[1]所述： Adaptive learning rates are fundamentally different from CLR policies, and CLR can be combined with adaptive learning rates, as shown in Section 4.1. In addition, CLR policies are computationally simpler than adaptive learning rates. CLR is likely most similar to the SGDR method that appeared recently. Why it works直觉上看，随着训练进度的增加我们应该保持学习率一直减小以便于在某一时刻达到收敛。 然而，事实恰与直觉相反，使用一个在给定区间里周期性变化的LR可能更有用处。原因是周期性高的学习率能够使模型跳出在训练过程中遇到的局部最低点和马鞍点。事实上，Dauphin等[3]指出相比于局部最低点，马鞍点更加阻碍收敛。如果马鞍点正好发生在一个巧妙的平衡点，小的学习率通常不能产生足够大的梯度改变使其跳过该点（即使跳过，也需要花费很长时间）。这正是周期性高学习率的作用所在，它能够更快地跳过马鞍点。 Fig.: A saddle point in the error surface (Img Credit: safaribooksonline) 另外一个好处是，最优的LR肯定落在最小值和最大值之间。换言之，我们确实在迭代过程中使用了最好的LR。 Epoch，iterations, cycles and stepsize首先介绍几个术语，理解这些术语可以更好地理解下面描述的算法和公式。 我们现在考虑一个包含50000个样本的训练集。 一个epoch是至将整个训练集训练一轮。如果我们将batch_size, 我们在一个epoch里会得到500个batch或者叫iteration。iteration的数目随着epoch的增加不断积累，在第二个epoch，对应着501到1000次iteration，后面的以此类推。 一个cycle定义为学习率从低到高，然后从高到低走一轮所用的iteration数。而stepsize指的是cycle迭代步数的一半。注意，cycle不一定必须和epoch相同，但实践上通常将cycle和epoch对应相同的iteration。 Fig: Triangular LR policy. (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 在上图中，两条红线分别表示学习率最小值（base lr）和学习率最大值（max lr）。蓝色的线是学习率随着iteration改变的方式。蓝线上下一次表示一个cycle，stepsize则是其一半。 Calculating the LR综上所述，接下来我们需要参数作为该算法的输入： stepsize base_lr max_lr 下面是LR更新的一段代码。 123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltdef get_triangular_lr(iteration, stepsize, base_lr, max_lr): """ Given the inputs, calculates the lr that should be applicable for this iteration """ cycle = np.floor(1 + iteration/(2 * stepsize)) x = np.abs(iteration/stepsize - 2 * cycle + 1) lr = base_lr + (max_lr - base_lr) * np.maximum(0, (1-x)) return lrif __name__ == '__main__': # Demo of how the LR varies with iterations num_iterations = 10000 stepsize = 1000 base_lr = 0.0001 max_lr = 0.001 lr_trend = list() for iteration in range(num_iterations): lr = get_triangular_lr(iteration, stepsize, base_lr, max_lr) # Update your optimizer to use this learning rate in this iteration lr_trend.append(lr) plt.plot(lr_trend) plt.show() 结果如下图所示。 Fig: Graph showing the variation of lr with iteration. We are using the triangular profile. Deriving the optimal base lr and max lr对于给定的数据集，怎么确定合理的base lr 和max lr呢？ 答案是先跑几个epoch，并且让学习率线性增加，观察准确率的变化，从中选出合适的base 和max lr。 我们让学习率按照上面的斜率进行增长，跑了几轮，结果如下图所示。 Fig: Plot of accuracy vs learning rate (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 可以看出，开始的时候，准确率随着学习率的增加而增加，然后进入平缓起期，然后又开始减小，出现震荡。注意图中准确率开始增长的那一点和达到平衡的那一点（图中红色箭头所示）。这两个点可以作为比较好的base lr 和 max lr。当然，你也可以选择平衡点旁边的准确率峰值点作为max lr， 把base lr 设为其1/3 或者1/4。 好了，三个参数中已经有两个确定了，那么怎么确定stepsize呢？ 已经有论文做过实验，他们将stepsize设成一个epoch包含的iteration数量的2-10倍。拿我们之前举的例子来说，我们一个epoch包含500个iteration，那么stepsize就设成1000-5000。该论文实验表明，stepsize设成2倍或者10倍，两者结果并没有太大的不同。 Variants上面我们实现的算法中，学习率是按照三角的规律周期性变化。除了这种以外，还有其他集中不同的函数形式。 traiangular2：这里max lr 按cycle进行对半衰减。 Fig: Graph showing the variation of lr with iteration for the triangular2 approach (Img Credit: Brad Kenstler) exp_range：这里max lr按iteration进行指数衰减。 Fig: Graph showing the variation of lr with iteration for the exp-range approach (Img Credit: Brad Kenstler) 这些与固定学习率的指数衰减（exponential decay）相比，有论文表明效果都得到了明显的提升。 Results如下图所示，在某神经网络上，CLR提供了一个快速的收敛，因此它的确值得一试。 Fig. CLR tested on CIFAR 10 (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 在上图的试验中，CLR花了25K次迭代达到了81%的准确率，传统的LR更新方法大约需要70K才能达到同样的水平。 Fig. CLR used with Nesterov and Adam. Much faster convergence with Nesterov (Nesterov is an improvement over SGD) (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 在另一项试验中，如上图所示，CLR + Nesterov优化器比著名的Adam收敛的还要快。 ConclusionCLR带来了一种新的方案来控制学习率的更新，它可以与SGD以及一些更加高级的优化器上一起使用。CLR应该成为每一个深度学习实践者工具箱里的一项技术。 References Cyclical Learning Rates for Training Neural Networks, Smith An overview of gradient descent optimization algorithms, Rudder Y. N. Dauphin, H. de Vries, J. Chung, and Y. Bengio. Rmsprop and equilibrated adaptive learning rates for non-convex optimization. SGDR: Stochastic Gradient Descent with Warm Restarts, Loshchilov, Hutter https://github.com/bckenstler/CLR]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>超参数</tag>
        <tag>学习率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像数据-TFrecord在动态图中的使用]]></title>
    <url>%2F2018%2F10%2F27%2FTFrecord%E5%9C%A8%E5%8A%A8%E6%80%81%E5%9B%BE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍图片数据使用TFrecord和tf.data.dataset进行存储和读取。 Tensorflow 提供了四种数据读取方式： Preloaded data: 用一个tf.constant常量将数据集加载进来，主要用于很小的数据集； Feeding: 使用python代码供给数据，将所有数据加载进内存，然后一个batch一个batch地输入到计算图中， 适用于小数据集； QueueRunner: 基于队列的输入通道，读取TFrecord静态图使用； tf.data API: 能够从不同的输入或文件格式中读取、预处理数据，并且对数据应用一些变换（例如，batching、shuffling、mapping function over the dataset），tf.data API 是旧的 feeding、QueueRunner的升级。值得注意的是， Eager模式必须使用该API来构建输入通道， 一般结合TFrecord使用。该API相比于Queue更容易使用。 What‘s TFrecordTFrecord是Tensorflow提供的一种二进制存储格式，可将数据和标签统一存储。从上述读取方式中可以看出，TFrecord在QueueRunner和tf.data API读取中均扮演了重要的角色。 Why TFrecord与其他方案相比， 使用TFrecord读取的优点在于： 可处理大规模数据量，而不会造成其他方案所带来的内存不够用的问题； 在Feeding方案中，batch读取的IO操作势必会阻塞训练，前一个batch加载完成后，神经网络必须等待下一个batch加载完成后才能继续训练，效率较低。 How To UseTFrecord的使用主要有两块：一是图片数据转TFrecord格式存储，二是解析存储好的TFrecord文件。下面逐一介绍。 图片转TFrecord本文使用的数据集是Kaggle猫狗数据集。 该数据集包含train和test两个文件夹， 分别为训练集和测试集，下面以train集为例操作。 123ls |wc -w25000 训练集包含25000张图片，猫狗各一半。 1234$ ls cat.124.jpg cat.3750.jpg cat.6250.jpg cat.8751.jpg dog.11250.jpg dog.2500.jpg dog.5000.jpg dog.7501.jpg... 图片文件以jpg格式存储，以cat， dog作为文件名开头。 1234567891011121314151617181920212223242526272829303132333435363738394041import osfrom tqdm import tqdmimport tensorflow as tfdef img_tfrecord_encode(classes, tfrecord_filename, data_path, is_training=True): """ 功能：读取图片转换成tfrecord格式的文件 @params: classes: 标签类别 @type：classes: dict @params: tfrecord_filename: tfrecord文件保存文件 @type：tfrecord_filename: str @params: data_path: 原始训练集存储路径 @is_training: 是否为训练集，用来区分训练集和测试集 """ # 初始化一个writer writer = tf.python_io.TFRecordWriter(tfrecord_filename) for img_name in tqdm(os.listdir(path)): name = img_name.split('.')[0] # 使用tf.gfile.FastFile读取图片要比PIL.Image读取处理得到的 # 最终TFrecod文件小得多，在本案例中，IMAGE方式读取得到的TFrecord大小约为3.7G # 而tf.gfile.FastFile得到的约为548M with tf.gfile.FastGFile(os.path.join(path, img_name), 'rb') as gf: img = gf.read() if is_training: # 构造特征 feature = &#123; 'label': tf.train.Feature(int64_list=tf.train.Int64List(value=[classes[name]])), 'img_raw': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img])), 'file_name': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_name.encode()])) &#125; else: feature = &#123; 'label': tf.train.Feature(int64_list=tf.train.Int64List(value=[-1])), 'img_raw':tf.train.Feature(bytes_list=tf.train.BytesList(value=[img])), 'file_name': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_name.encode()])) &#125; # example 对象将label和image特征进行封装 example = tf.train.Example(features=tf.train.Features(feature=feature)) writer.write(example.SerializeToString()) # 序列化为字符串 writer.close() print('tfrecord writen done!') 调用上述函数，可得到猫狗训练集的TFrecord格式文件 12345if __name__ == '__main__': classes = &#123;'cat': 0, 'dog': 1&#125; tfrecord_filename = 'cat_and_dog.tfrecord' data_path = 'train/' img_tfrecord_encode(classes, tfrecord_filename, data_path, is_training=True) 上述程序运行大约需要2min。 使用tf.data读取TFrecord在动态图（eager）模式下，QueueRunner不可用，必须使用tf.data进行TFrecord的读取。 12345678910111213141516171819202122232425262728293031323334353637383940def img_tfrecord_parse(tfrecord_filename, epochs, batch_size, shape, padded_shapes=None, shuffle=True, buffer_size=1000): """ @param: tfrecord_filename:tfrecord文件列表 @type:list @param: epoch:训练轮数（repeating次数） @type:int @param：batch_size:批数据大小 @type:int @param: shape:图片维度 @type:tuple @param: padded_shapes:不定长padding @type:tuple @param: shuffle:是否打乱 @type:boolean """ # 解析单个example，特征与encode一一对应。 def parse_example(serialized_example): features = tf.parse_single_example(serialized_example, features=&#123; 'label': tf.FixedLenFeature([], tf.int64), 'img_raw': tf.FixedLenFeature([], tf.string), 'file_name': tf.FixedLenFeature([], tf.string) &#125;) # 解码 image = tf.image.decode_jpeg(features['img_raw']) # 设置shape image = tf.image.resize_images(image, shape, method=1) label = tf.cast(features['label'], tf.int64) file_name = tf.cast(features['file_name'], tf.string) return image, label, file_name # 解析TFrecord dataset = tf.data.TFRecordDataset(tfrecord_filename).map(parse_example) if shuffle: if padded_shapes: dataset = dataset.repeat(epochs).shuffle(buffer_size=buffer_size).padded_batch(batch_size, padded_shapes) else: dataset = dataset.repeat(epochs).shuffle(buffer_size=buffer_size).batch(batch_size) else: if padded_shapes: dataset = dataset.repeat(epochs).padded_batch(batch_size, padded_shapes) else: dataset = dataset.repeat(epochs).batch(batch_size) return dataset 调用上述函数，解析TFrecord得到dataset。 123456789101112131415if __name__ == '__main__'(): tfrecord_filename = 'cat_and_dog.tfrecord' epochs = 100 batch_size = 64 shape = (227, 227) dataset = img_tfrecord_parse(tfrecord_filename=tfrecord_filename, epochs=epochs, batch_size=batch_size, shape=shape) # 查看dataset iterator = dataset.make_one_hot_iterator() image, label, file_name = iterator.get_next() print(image[0]) print(label[0]) print(file_name[0])]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
</search>
