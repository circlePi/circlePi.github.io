<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析pytorch中的LSTM(GRU)]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%B5%85%E6%9E%90pytorch%E4%B8%AD%E7%9A%84LSTM(GRU)%20%2F</url>
    <content type="text"><![CDATA[Introduction本文介绍pytorch RNN网络搭建，主要包括LSTM和GRU的使用。 最近从tensorflow入坑pytorch，发现两者的RNN模块前向传播有些不同。特别是RNN中的pack_padded_sequence和pad_packed_sequence。 Backgroundtensorflow的BILSTM以BILSTM为例，tensorflow中我们一般这样操作： 先定义个前向层 1self.fw_cell = tf.nn.rnn_cell.LSTMCell(num_units=cell_size) 在定义一个后向层 1self.bw_cell = tf.nn.rnn_cell.LSTMCell(num_units=cell_size) 然后前向传播是这个样子的 123456789101112131415161718192021def call(self, inputs, seq_length, training): # 嵌入层 embedded_words = self.embeddings(inputs) # RNN层 outputs, final_state = tf.nn.bidirectional_dynamic_rnn( self.fw_cell, self.bw_cell, inputs=embedded_words, # 句子原始长度（batch_size，1） sequence_length=seq_length, dtype=tf.float32, time_major=False) # 合并前后向的结果 # outputs是一个列表:[（batch_size, cell_size）,(...)] # len(output) = time_steps outputs = tf.concat(outputs, axis=2) # 由于采用的是dynamic_rnn，padding部分自动被截断了 # 这里取最后一维就好了 final_output = outputs[-1] logits = self.Dense(final_output) return logits 可以看到，tensorflow的dynamic LSTM有两个特点： 前向传播时，不看词向量维度的话，输入是个二维（batch_size, time_steps) padding部分不参与计算，会被自动截断 with this in our mind, let‘s see what’s the bilstm in pytorch。 Pytorch BILSTMLSTM定义一般这样操作： 先定义个LSTM 12345self.rnn_cell = nn.LSTM(input_size=word_embedding_dimension, hidden_size=hidden_size, num_layers=num_layer, batch_first=True, bidirectional=bi_flag) 双向的怎么办呢, 改个参数就行了 1bidirectional=True 多层呢 1num_layers=True 可以看到，pytorch的LSTM把所有的功能整合到一起了，不需要定义前向后向（当然我们也可以搞两个单向的）。此外，我们除了要传递隐藏层的个数cell_size, 还需要将词向量的维度传递进来，这是为什么呢？ 这还不是关键。关键在于pytorch的动态padding机制。因为我们一般是将输入作为batch传进来的，对于变长的文本来说，padding是不可避免的。但是在我们使用LSTM进行计算时，是不希望padding部分参与计算的（他们不是真实的文本，假如纳入计算，会引入不必要的噪声和不必要的计算量）。tensorflow采用dynamic LSTM很好地解决了这一问题。pytorch当然也有他自己的一套，下面来看看。 pack_padded_sequence我们从embedding层拿到的输入维度为（batch_size, time_steps, word_embedding_dimension）, 并不将他直接喂给LSTM，而是要预加工一下，这时候第一个重要的函数pack_padded_sequence就登场了，可以将其看成一个截断函数，作用就是将padding部分截断。不仅如此，阶段后会将输入拉平，变成（batch_size*time_steps, word_embedding_dimension）, 仔细看一下，降了一个维度。来看实例： 123456789import torchfrom torch.nn.utils.rnn import pack_padded_sequence # 手动造个张量, 包含3个序列，长度分别为10,5,3，使用0进行paddingx = torch.FloatTensor([[[1],[2],[3],[4],[5],[6],[7],[8],[8],[9]],[[1], [2],[3],[4],[5],[0],[0],[0],[0],[0]],[[5],[4],[6],[0],[0],[0],[0],[0],[0],[0]]])print("x shape is：", x.shape)# x 的真实长度length = torch.LongTensor([10, 5,3])x_packed = pack_padded_sequence(x, length,batch_first=True)print(x_packed) 结果为： 12345678910111213141516171819x shape is：（3，10，1）PackedSequence(data=tensor([[1.], [1.], [5.], [2.], [2.], [4.], [3.], [3.], [6.], [4.], [4.], [5.], [5.], [6.], [7.], [8.], [8.], [9.]]), batch_sizes=tensor([3, 3, 3, 2, 2, 1, 1, 1, 1, 1])) 这里有几点要说一下： 输入的张量是已经按照长度排序的！这是必须的，否则pack_padded_sequence函数会报错！一般而言排序有两种做法，一是使用torch.sort函数，第二是在构造batch时使用torchtext进行batch内排序，见我上篇博文 经过pack，输入发生了三个变化。一是由三维变成了2维(18,1)，二是padding部分的0没有了，三是对序列进行了拼接，这其实是维度降低的结果 pack完之后的结果是个tuple，tuple[0]是数据，是按列进行拼接的，tuple[1]是batch_size, 跟我们之前的batch_size是不一样的，这是为了我们后面可以还原 好了，现在pddding问题解决了，我们将它输入进LSTM，前向传播是这样的： 123456789101112def forward(self, inputs, length): """前向传播""" embeddings = self.embedding(inputs, length) # (batch_size, time_steps, embedding_dim) # 去除padding元素 # embeddings_packed: (batch_size*time_steps, embedding_dim) embeddings_packed = pack_padded_sequence(embeddings, length, batch_first=True) output, (h_n, c_n) = self.rnn_cell(embeddings_packed, (h_0, c_0)) # padded_output: (batch_size, time_steps, hidden_size * bi_num) # h_n|c_n: (num_layer*bi_num, batch_size, hidden_size) padded_output, length = pad_packed_sequence(output, batch_first=True) # 取最后一个有效输出作为最终输出（0为无效输出） last_output = padded_output[0] 这里做下参数说明： batch_first 类型：bool， True，输入的维度为（batch_size，time_steps, word_embedding_dimension）；False，输入维度为（time_steps, batch_size, word_embedding_dimension） h_0: 初始化隐藏态 c_0: 初始化细胞态 output：输出，为一个tuple，后面会用例子说明 h_n: 最后个隐藏态 c_n: 最后个细胞态 还是以上面我们造的那个张量为例，看下输出： 1234567import torch.nn as nnbirnn = nn.LSTM(input_size=1, hidden_size=8, bidirectional=True)output, (h_n, c_n) = birnn(x_packed)print('output:\n', output)print('h_n shape:\n',h_n.shape)print('c_n shape:\n',c_n.shape) 结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243output: PackedSequence(data=tensor([[-0.0087, 0.0716, 0.0069, -0.0040, -0.1375, 0.0404, 0.0757, 0.0291, 0.0619, 0.0213, 0.1517, 0.0241, 0.2986, -0.2594, -0.1432, -0.1742], [-0.0087, 0.0716, 0.0069, -0.0040, -0.1375, 0.0404, 0.0757, 0.0291, 0.0486, 0.0195, 0.1454, 0.0138, 0.2596, -0.2467, -0.1491, -0.1596], [-0.1019, 0.1606, -0.0482, -0.0519, -0.1932, 0.2632, -0.0423, 0.0774, 0.0434, 0.0142, 0.0915, -0.0455, 0.2970, -0.6665, -0.0578, -0.0521], [-0.0895, 0.1504, -0.0069, -0.0137, -0.2248, 0.1365, 0.1002, 0.0918, 0.0730, 0.0247, 0.1526, 0.0160, 0.3559, -0.4301, -0.1375, -0.1429], [-0.0895, 0.1504, -0.0069, -0.0137, -0.2248, 0.1365, 0.1002, 0.0918, 0.0517, 0.0197, 0.1431, -0.0005, 0.2929, -0.4016, -0.1401, -0.1218], [-0.1855, 0.2300, -0.0625, -0.0508, -0.2488, 0.2741, -0.0638, 0.1441, 0.0239, 0.0137, 0.0786, -0.0524, 0.2311, -0.5685, -0.0673, -0.0485], [-0.1621, 0.2254, -0.0318, -0.0240, -0.2693, 0.2207, 0.0843, 0.1487, 0.0789, 0.0259, 0.1354, 0.0050, 0.3851, -0.5676, -0.1110, -0.1117], [-0.1621, 0.2254, -0.0318, -0.0240, -0.2693, 0.2207, 0.0843, 0.1487, 0.0439, 0.0172, 0.1198, -0.0221, 0.2856, -0.5105, -0.1089, -0.0852], [-0.1346, 0.3093, -0.0775, -0.0678, -0.2616, 0.2946, -0.1167, 0.1699, -0.0280, 0.0067, 0.0333, -0.0924, 0.1308, -0.5332, -0.0237, -0.0201], [-0.1886, 0.2883, -0.0563, -0.0352, -0.2872, 0.2700, 0.0431, 0.1887, 0.0803, 0.0254, 0.1112, -0.0077, 0.3929, -0.6681, -0.0804, -0.0828], [-0.1886, 0.2883, -0.0563, -0.0352, -0.2872, 0.2700, 0.0431, 0.1887, 0.0194, 0.0129, 0.0852, -0.0521, 0.2364, -0.5524, -0.0720, -0.0538], [-0.1767, 0.3363, -0.0719, -0.0475, -0.2858, 0.2911, -0.0109, 0.2141, 0.0779, 0.0234, 0.0866, -0.0215, 0.3831, -0.7393, -0.0539, -0.0580], [-0.1767, 0.3363, -0.0719, -0.0475, -0.2858, 0.2911, -0.0109, 0.2141, -0.0274, 0.0076, 0.0448, -0.0817, 0.1408, -0.4683, -0.0382, -0.0285], [-0.1470, 0.3710, -0.0771, -0.0605, -0.2693, 0.2962, -0.0684, 0.2291, 0.0724, 0.0204, 0.0651, -0.0356, 0.3568, -0.7885, -0.0341, -0.0385], [-0.1142, 0.3956, -0.0744, -0.0727, -0.2434, 0.2935, -0.1226, 0.2366, 0.0636, 0.0164, 0.0477, -0.0497, 0.3136, -0.8199, -0.0208, -0.0245], [-0.0854, 0.4126, -0.0669, -0.0829, -0.2140, 0.2871, -0.1699, 0.2389, 0.0496, 0.0118, 0.0343, -0.0641, 0.2542, -0.8307, -0.0124, -0.0151], [-0.0847, 0.4176, -0.0620, -0.0877, -0.2053, 0.2863, -0.2063, 0.2468, 0.0281, 0.0090, 0.0254, -0.0784, 0.1827, -0.7871, -0.0100, -0.0116], [-0.0620, 0.4284, -0.0550, -0.0931, -0.1827, 0.2785, -0.2409, 0.2438, -0.0278, 0.0044, 0.0120, -0.1073, 0.0924, -0.6543, -0.0047, -0.0063]], grad_fn=&lt;CatBackward&gt;), batch_sizes=tensor([3, 3, 3, 2, 2, 1, 1, 1, 1, 1]))h_n shape: torch.Size([2, 3, 8])c_n shape: torch.Size([2, 3, 8]) output由一个tuple组成，第一个元素就是输出，这里的维度为torch.Size([18, 16])，第二个元素和我们之前pack时的batch_size参数一样。 h_n和c_n分别为两个三维张量，维度如上，因为是双向，第一维为2. 到这里是不是就结束了呢，当然不是，pack完了之后经过LSTM输出了结果，看上去很费劲，因为序列连一起了，batch都没了。所以我们还原，这时候就用到pack_padded_sequence的好基友pad_packed_sequence了。 pad_packed_sequencepad_packed_sequence可以看成是解压缩操作。从上面可以看到，h_n, c_n已经是正常维度的张量了，没有pack，当然也用不着pad。我们只需对output做pad。 12345padded_output, length = pad_packed_sequence(output, batch_first=True)print('padded_output\n', padded_output)print('padded_output shape\n', padded_output.shape)print('length\n',length) 结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697padded_output tensor([[[-0.0087, 0.0716, 0.0069, -0.0040, -0.1375, 0.0404, 0.0757, 0.0291, 0.0619, 0.0213, 0.1517, 0.0241, 0.2986, -0.2594, -0.1432, -0.1742], [-0.0895, 0.1504, -0.0069, -0.0137, -0.2248, 0.1365, 0.1002, 0.0918, 0.0730, 0.0247, 0.1526, 0.0160, 0.3559, -0.4301, -0.1375, -0.1429], [-0.1621, 0.2254, -0.0318, -0.0240, -0.2693, 0.2207, 0.0843, 0.1487, 0.0789, 0.0259, 0.1354, 0.0050, 0.3851, -0.5676, -0.1110, -0.1117], [-0.1886, 0.2883, -0.0563, -0.0352, -0.2872, 0.2700, 0.0431, 0.1887, 0.0803, 0.0254, 0.1112, -0.0077, 0.3929, -0.6681, -0.0804, -0.0828], [-0.1767, 0.3363, -0.0719, -0.0475, -0.2858, 0.2911, -0.0109, 0.2141, 0.0779, 0.0234, 0.0866, -0.0215, 0.3831, -0.7393, -0.0539, -0.0580], [-0.1470, 0.3710, -0.0771, -0.0605, -0.2693, 0.2962, -0.0684, 0.2291, 0.0724, 0.0204, 0.0651, -0.0356, 0.3568, -0.7885, -0.0341, -0.0385], [-0.1142, 0.3956, -0.0744, -0.0727, -0.2434, 0.2935, -0.1226, 0.2366, 0.0636, 0.0164, 0.0477, -0.0497, 0.3136, -0.8199, -0.0208, -0.0245], [-0.0854, 0.4126, -0.0669, -0.0829, -0.2140, 0.2871, -0.1699, 0.2389, 0.0496, 0.0118, 0.0343, -0.0641, 0.2542, -0.8307, -0.0124, -0.0151], [-0.0847, 0.4176, -0.0620, -0.0877, -0.2053, 0.2863, -0.2063, 0.2468, 0.0281, 0.0090, 0.0254, -0.0784, 0.1827, -0.7871, -0.0100, -0.0116], [-0.0620, 0.4284, -0.0550, -0.0931, -0.1827, 0.2785, -0.2409, 0.2438, -0.0278, 0.0044, 0.0120, -0.1073, 0.0924, -0.6543, -0.0047, -0.0063]], [[-0.0087, 0.0716, 0.0069, -0.0040, -0.1375, 0.0404, 0.0757, 0.0291, 0.0486, 0.0195, 0.1454, 0.0138, 0.2596, -0.2467, -0.1491, -0.1596], [-0.0895, 0.1504, -0.0069, -0.0137, -0.2248, 0.1365, 0.1002, 0.0918, 0.0517, 0.0197, 0.1431, -0.0005, 0.2929, -0.4016, -0.1401, -0.1218], [-0.1621, 0.2254, -0.0318, -0.0240, -0.2693, 0.2207, 0.0843, 0.1487, 0.0439, 0.0172, 0.1198, -0.0221, 0.2856, -0.5105, -0.1089, -0.0852], [-0.1886, 0.2883, -0.0563, -0.0352, -0.2872, 0.2700, 0.0431, 0.1887, 0.0194, 0.0129, 0.0852, -0.0521, 0.2364, -0.5524, -0.0720, -0.0538], [-0.1767, 0.3363, -0.0719, -0.0475, -0.2858, 0.2911, -0.0109, 0.2141, -0.0274, 0.0076, 0.0448, -0.0817, 0.1408, -0.4683, -0.0382, -0.0285], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]], [[-0.1019, 0.1606, -0.0482, -0.0519, -0.1932, 0.2632, -0.0423, 0.0774, 0.0434, 0.0142, 0.0915, -0.0455, 0.2970, -0.6665, -0.0578, -0.0521], [-0.1855, 0.2300, -0.0625, -0.0508, -0.2488, 0.2741, -0.0638, 0.1441, 0.0239, 0.0137, 0.0786, -0.0524, 0.2311, -0.5685, -0.0673, -0.0485], [-0.1346, 0.3093, -0.0775, -0.0678, -0.2616, 0.2946, -0.1167, 0.1699, -0.0280, 0.0067, 0.0333, -0.0924, 0.1308, -0.5332, -0.0237, -0.0201], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]], grad_fn=&lt;TransposeBackward0&gt;)padded_output shape torch.Size([3, 10, 16])length tensor([10, 5, 3]) 是不是又回来了？16是cell_size*2, 因为是双向。 可以看到，没参与计算后来被补上来的部分都成为了0！ 完整代码tensorflow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182mport osimport timeimport numpy as npimport tensorflow as tffrom util.embedding_util import get_embeddingfrom util.plot_util import loss_acc_plotfrom util.lr_util import lr_updateimport config.lstm_config as configclass BILSTM(tf.keras.Model): def __init__(self, cell_size, checkpoint_dir, num_classes, model_type, vocab_size, word2id, embedding_dim, keep_prob): super().__init__() self.checkpoint_dir = checkpoint_dir self.history = &#123;&#125; self.keep_prob = keep_prob # embedding layer weights = get_embedding(model_type=model_type, word2id=word2id, embedding_dim=embedding_dim) if model_type == 'static': self.embeddings = tf.keras.layers.Embedding(vocab_size, embedding_dim, weights=weights, trainable=False) elif model_type == 'non-static': self.embeddings = tf.keras.layers.Embedding(vocab_size, embedding_dim, weights=weights, trainable=True) elif model_type == 'rand': self.embeddings = tf.keras.layers.Embedding(vocab_size, embedding_dim, weights=weights, trainable=True) elif model_type == 'multichannel': pass else: raise ValueError('unknown model type') # BILSTM layer self.fw_cell = tf.nn.rnn_cell.DropoutWrapper( tf.nn.rnn_cell.LSTMCell(num_units=cell_size), output_keep_prob=0.7) self.bw_cell = tf.nn.rnn_cell.DropoutWrapper( tf.nn.rnn_cell.LSTMCell(num_units=cell_size), output_keep_prob=0.7) self.Dense = tf.layers.Dense(units=num_classes, activation=None) def call(self, inputs, seq_length, training): embedded_words = self.embeddings(inputs) outputs, final_state = tf.nn.bidirectional_dynamic_rnn( self.fw_cell, self.bw_cell, inputs=embedded_words, sequence_length=seq_length, dtype=tf.float32, time_major=False) outputs = tf.concat(outputs, axis=2) final_output = outputs[-1] logits = self.Dense(final_output) return logits def loss_fn(self, inputs, target, seq_length, training): preds = self.call(inputs, seq_length, training) # L2正则化 loss_L2 = tf.add_n([tf.nn.l2_loss(v) for v in self.trainable_variables if 'bias' not in v.name]) * 0.001 loss = tf.losses.sparse_softmax_cross_entropy(labels=target, logits=preds) loss = loss + loss_L2 return loss def grads_fn(self, inputs, target, seq_length, training): with tf.GradientTape() as tape: loss = self.loss_fn(inputs, target, seq_length, training) return tape.gradient(loss, self.variables) def save_model(self, model): """ Function to save trained model. """ checkpoint = tf.train.Checkpoint(model=model) checkpoint_prefix = os.path.join(self.checkpoint_dir, 'ckpt') checkpoint.save(file_prefix=checkpoint_prefix) def restore_model(self): # Run the model once to initialize variables dummy_input = tf.constant(tf.zeros((1, 1))) dummy_length = tf.constant(1, shape=(1,)) self(dummy_input, dummy_length, False) # Restore the variables of the model saver = tf.contrib.Saver(self.variables) saver.restore(tf.train.latest_checkpoint (self.checkpoint_directory)) def get_accuracy(self, inputs, target, seq_length, training): y = self.call(inputs, seq_length, training) y_pred = tf.argmax(y, axis=1) correct = tf.where(tf.equal(y_pred, target)).numpy().shape[0] total = target.numpy().shape[0] return correct/total def fit(self, training_data, eval_data, pbar, num_epochs=100, early_stopping_rounds=5, verbose=1, train_from_scratch=True): """train the model""" if train_from_scratch is False: self.restore_model() # Initialize best loss. This variable will store the lowest loss on the # eval dataset. best_loss = 2018 # Initialize classes to update the mean loss of train and eval train_loss = [] eval_loss = [] train_accuracy = [] eval_accuracy = [] # Initialize dictionary to store the loss history self.history['train_loss'] = [] self.history['eval_loss'] = [] self.history['train_accuracy'] = [] self.history['eval_accuracy'] = [] count = early_stopping_rounds # Begin training for i in range(num_epochs): # 在每个epoch训练之初初始化optimizer，决定是否使用学习率衰减 learning_rate = lr_update(i+1, mode=config.lr_mode) optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate) # Training with gradient descent start = time.time() for index, (sequence, label, seq_length) in enumerate(training_data): # cpu需要类型转换，不然会报错：Could not find valid device sequence = tf.cast(sequence, dtype=tf.float32) label = tf.cast(label, dtype=tf.int64) grads = self.grads_fn(sequence, label, seq_length, training=True) optimizer.apply_gradients(zip(grads, self.variables)) pbar.show(index, use_time=time.time()-start) # Compute the loss on the training data after one epoch for sequence, label, seq_length in training_data: sequence = tf.cast(sequence, dtype=tf.float32) label = tf.cast(label, dtype=tf.int64) train_los = self.loss_fn(sequence, label, seq_length, training=False) train_acc = self.get_accuracy(sequence, label, seq_length, training=False) train_loss.append(train_los) train_accuracy.append(train_acc) self.history['train_loss'].append(np.mean(train_loss)) self.history['train_accuracy'].append(np.mean(train_accuracy)) # Compute the loss on the eval data after one epoch for sequence, label, seq_length in eval_data: sequence = tf.cast(sequence, dtype=tf.float32) label = tf.cast(label, dtype=tf.int64) eval_los = self.loss_fn(sequence, label, seq_length, training=False) eval_acc = self.get_accuracy(sequence, label, seq_length, training=False) eval_loss.append(eval_los) eval_accuracy.append(eval_acc) self.history['eval_loss'].append(np.mean(eval_loss)) self.history['eval_accuracy'].append(np.mean(eval_accuracy)) # Print train and eval losses if (i == 0) | ((i + 1) % verbose == 0): print('Epoch %d - train_loss: %4f - eval_loss: %4f - train_acc:%4f - eval_acc:%4f' % (i + 1, self.history['train_loss'][-1], self.history['eval_loss'][-1], self.history['train_accuracy'][-1], self.history['eval_accuracy'][-1])) # Check for early stopping if self.history['eval_loss'][-1] &lt; best_loss: best_loss = self.history['eval_loss'][-1] count = early_stopping_rounds else: count -= 1 if count == 0: break # 画出loss_acc曲线 loss_acc_plot(history=self.history) pytorch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import osimport torchimport torch.nn as nnimport torch.nn.functional as Ffrom torch.nn.utils.rnn import pad_packed_sequence, pack_padded_sequencefrom sklearn.metrics import f1_scoreimport numpy as npimport config.config as configfrom util.embedding_util import get_embeddingtorch.manual_seed(2018)torch.cuda.manual_seed(2018)torch.cuda.manual_seed_all(2018)np.random.seed(2018)os.environ["CUDA_VISIBLE_DEVICE"] = "1"class RNN(nn.Module): def __init__(self, vocab_size, word_embedding_dimension, hidden_size, bi_flag, num_layer, labels, cell_type, dropout, checkpoint_dir): super(RNN, self).__init__() self.labels = labels self.num_label = len(labels) self.num_layer = num_layer self.hidden_size = hidden_size self.dropout = dropout self.checkpoint_dir = checkpoint_dir if torch.cuda.is_available(): self.device = torch.device("cuda") self.embedding = nn.Embedding(vocab_size, word_embedding_dimension) for p in self.embedding.parameters(): p.requires_grad = False self.embedding.weight.data.copy_(torch.from_numpy(get_embedding(vocab_size, word_embedding_dimension))) if cell_type == "LSTM": self.rnn_cell = nn.LSTM(input_size=word_embedding_dimension, hidden_size=hidden_size, num_layers=num_layer, batch_first=True, dropout=dropout, bidirectional=bi_flag) elif cell_type == "GRU": self.rnn_cell = nn.GRU(input_size=word_embedding_dimension, hidden_size=hidden_size, num_layers=num_layer, batch_first=True, dropout=dropout, bidirectional=bi_flag) else: raise TypeError("RNN: Unknown rnn cell type") # 是否双向 self.bi_num = 2 if bi_flag else 1 self.linear = nn.Linear(hidden_size*self.bi_num, self.num_label) def forward(self, inputs, length): batch_size = inputs.shape[0] # 初始化态h和C,默认为zeros h_0 = torch.zeros(self.num_layer*self.bi_num, batch_size, self.hidden_size).float() c_0 = torch.zeros(self.num_layer*self.bi_num, batch_size, self.hidden_size).float() embeddings = self.embedding(inputs, length) # (batch_size, time_steps, embedding_dim) # 去除padding元素 # embeddings_packed: (batch_size*time_steps, embedding_dim) embeddings_packed = pack_padded_sequence(embeddings, length, batch_first=True) output, (h_n, c_n) = self.rnn_cell(embeddings_packed, (h_0, c_0)) # padded_output: (batch_size, time_steps, hidden_size * bi_num) # h_n|c_n: (num_layer*bi_num, batch_size, hidden_size) padded_output, _ = pad_packed_sequence(output, batch_first=True) # 取最后一个有效输出作为最终输出（0为无效输出） last_output = padded_output[torch.LongTensor(range(batch_size)), length] last_output = F.dropout(last_output, p=self.dropout, training=self.training) output = self.linear(last_output) return output def load(self): self.load_state_dict(torch.load(self.checkpoint_dir)) def save(self): torch.save(self.state_dict(), self.checkpoint_dir) def evaluate(self, y_pred, y_true): _, y_pred = torch.max(y_pred.data, 1) if config.use_cuda: y_true = y_true.cpu().numpy() y_pred = y_pred.cpu().numpy() else: y_true = y_true.numpy() y_pred = y_pred.numpy() f1 = f1_score(y_true, y_pred, labels=self.labels, average="macro") correct = np.sum((y_true==y_pred).astype(int)) acc = correct/y_pred.shape[0] return (acc, f1) 各位晚安~]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch，lstm，nlp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本预处理]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Introduction在做NLP的深度学习任务时，一个关键的问题是如何构建输入。本文介绍如何利用有限内存进行大规模数据处理，主要包括： 建立词典 将单词转换为id 训练集验证集切分 How To Do IT原始数据集123411@成都 高新技术 产业 开发区 人民 检察院 指控 ， 2015年 3 月 29日 23时 许 ， 被告人 刘某 某 饮 酒后 驾驶川 A ＊ ＊ ＊ 84 北京 现代牌 小型 轿车 ， 从 成都市 桐梓林 附近 出发 上 人民 南 路 出 城 ， 当 车 行驶 至 成都 高新区 天府 大道 与 府城 大道 交叉 路口处 时 ， 公诉 机关 认为 ， 被告人 刘 某某 在 道路 上 醉 酒 驾驶 机动车 ， 危害 公共 安全 ， 其 行为 应当 以 ×× 追究 其 刑事 责任 。11@黑龙江省 尚志市 人民 检察院 指控 ： ×× 2014年 9 月 22日 20时 许 ， 被告人 矫 2 某 在 尚志市 苇河镇 阿里郎歌厅 对面 停放 的 货车 的 副 驾驶 座位 上 ， 将 被害人 李某 甲 的 蓝色 女式 拎 包 盗 走 ， 包 内 有 人民币 57000 元 ， 红色 钱包 一个 ， 农业 银行卡 一 张 ， 身份证 一 张 、 驾驶证 一 本 、 账本 一 册 。 案 发 前 ， 被告人 矫 2 某 将 盗走 的 财物 返还 被害人 。 在 ×× 到 五 年 幅度 内 量刑 ， 并 处 罚金 ； 对 所 犯 的 ×× 在 ×× 到 六 个 月 幅度 内 量刑 ， 并 处 罚金 。 针对 上述 指控 ， 公诉 机关 提供 了 相应 的 证据 。... 这里以法研杯比赛的文本数据集为例。格式为 标签@文本 其中，文本已经过分词处理，使用空格分隔。 建立词典123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566def sent_label_split(line): """ 句子处理成单词 :param line: 原始行 :return: 单词， 标签 """ line = line.strip('\n').split('@') label = line[0] sent = line[1].split(' ') return sent, labeldef word_to_id(word, word2id): """ 单词--&gt;ID :param word: 单词 :param word2id: word2id @type: dict :return: """ return word2id[word] if word in word2id else word2id['unk']def bulid_vocab(vocab_size, min_freq=3, stop_word_list=None, is_debug=False): """ 建立词典 :param vocab_size: 词典大小 :param min_freq: 最小词频限制 :param stop_list: 停用词 @type：file_path :param is_debug: 是否测试模式 @type: bool True:使用很小的数据集进行代码测试 :return: word2id """ size = 0 count = Counter() with open(os.path.join(config.ROOT_DIR, config.RAW_DATA), 'r') as fr: logger.info('Building vocab') for line in tqdm(fr, desc='Build vocab'): words, label = sent_label_split(line) count.update(words) size += 1 if is_debug: limit_train_size = 10000 if size &gt; limit_train_size: break if stop_word_list: stop_list = &#123;&#125; with open(os.path.join(config.ROOT_DIR, config.STOP_WORD_LIST), 'r') as fr: for i, line in enumerate(fr): word = line.strip('\n') if stop_list.get(word) is None: stop_list[word] = i count = &#123;k: v for k, v in count.items() if k not in stop_list&#125; count = sorted(count.items(), key=operator.itemgetter(1)) # 词典 vocab = [w[0] for w in count if w[1] &gt;= min_freq] if vocab_size &lt; len(vocab): vocab = vocab[:vocab_size] vocab = config.flag_words + vocab logger.info('vocab_size is %d'%len(vocab)) # 词典到编号的映射 word2id = &#123;k: v for k, v in zip(vocab, range(0, len(vocab)))&#125; assert word2id['&lt;pad&gt;'] == 0, "ValueError: '&lt;pad&gt;' id is not 0" print(word2id) with open(config.WORD2ID_FILE, 'wb') as fw: pickle.dump(word2id, fw) return word2id 文本映射到Id123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def text2id(word2id, maxlen=None, valid_size=0.3, random_state=2018, shuffle=True, is_debug=False): """ 训练集文本转ID :param valid_size: 验证集大小 """ print(os.path.join(config.ROOT_DIR, config.TRAIN_FILE)) if len(glob(os.path.join(config.ROOT_DIR, config.TRAIN_FILE))) &gt; 0: logger.info('Text to id file existed') return logger.info('Text to id') sentences, labels, lengths = [], [], [] size = 0 with open(os.path.join(config.ROOT_DIR, config.RAW_DATA), 'r') as fr: for line in tqdm(fr, desc='text_to_id'): words, label = sent_label_split(line) sent = [word_to_id(word=word, word2id=word2id) for word in words] if maxlen: sent = sent[:maxlen] length = len(sent) sentences.append(sent) labels.append(label) lengths.append(length) size += 1 if is_debug: limit_train_size = 10000 if size &gt; limit_train_size: break train, valid = train_val_split(sentences, labels, valid_size=valid_size, random_state=random_state, shuffle=shuffle) del sentences, labels, lengths with open(config.TRAIN_FILE, 'w') as fw: for sent, label in train: sent = [str(s) for s in sent] line = "\t".join[str(label), " ".join(sent)] fw.write(line + '\n') logger.info('Writing train to file done') with open(config.VALID_FILE, 'w') as fw: for sent, label in train: sent = [str(s) for s in sent] line = "\t".join[str(label), " ".join(sent)] fw.write(line + '\n') logger.info('Writing valid to file done') 训练集验证集分割12345678910111213141516171819def train_val_split(X, y, valid_size=0.3, random_state=2018, shuffle=True): """ 训练集验证集分割 :param X: sentences :param y: labels :param random_state: 随机种子 """ logger.info('train val split') data = [(data_x, data_y) for data_x, data_y in zip(X, y)] N = len(data) test_size = int(N * valid_size) if shuffle: random.seed(random_state) random.shuffle(data) valid = data[:test_size] train = data[test_size:] return train, valid 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import osimport randomimport pickleimport operatorfrom glob import globfrom tqdm import tqdmfrom collections import Counterimport configfrom Logginger import init_loggerlogger = init_logger("torch", logging_path=config.LOG_PATH)def sent_label_split(line): """ 句子处理成单词 :param line: 原始行 :return: 单词， 标签 """ line = line.strip('\n').split('@') label = line[0] sent = line[1].split(' ') return sent, labeldef word_to_id(word, word2id): """ 单词--&gt;ID :param word: 单词 :param word2id: word2id @type: dict :return: """ return word2id[word] if word in word2id else word2id['unk']def bulid_vocab(vocab_size, min_freq=3, stop_word_list=None, is_debug=False): """ 建立词典 :param vocab_size: 词典大小 :param min_freq: 最小词频限制 :param stop_list: 停用词 @type：file_path :param is_debug: 是否测试模式 @type: bool True:使用很小的数据集进行代码测试 :return: word2id """ size = 0 count = Counter() with open(os.path.join(config.ROOT_DIR, config.RAW_DATA), 'r') as fr: logger.info('Building vocab') for line in tqdm(fr, desc='Build vocab'): words, label = sent_label_split(line) count.update(words) size += 1 if is_debug: limit_train_size = 10000 if size &gt; limit_train_size: break if stop_word_list: stop_list = &#123;&#125; with open(os.path.join(config.ROOT_DIR, config.STOP_WORD_LIST), 'r') as fr: for i, line in enumerate(fr): word = line.strip('\n') if stop_list.get(word) is None: stop_list[word] = i count = &#123;k: v for k, v in count.items() if k not in stop_list&#125; count = sorted(count.items(), key=operator.itemgetter(1)) # 词典 vocab = [w[0] for w in count if w[1] &gt;= min_freq] if vocab_size &lt; len(vocab): vocab = vocab[:vocab_size] vocab = config.flag_words + vocab logger.info('vocab_size is %d'%len(vocab)) # 词典到编号的映射 word2id = &#123;k: v for k, v in zip(vocab, range(0, len(vocab)))&#125; assert word2id['&lt;pad&gt;'] == 0, "ValueError: '&lt;pad&gt;' id is not 0" print(word2id) with open(config.WORD2ID_FILE, 'wb') as fw: pickle.dump(word2id, fw) return word2iddef train_val_split(X, y, valid_size=0.3, random_state=2018, shuffle=True): """ 训练集验证集分割 :param X: sentences :param y: labels :param random_state: 随机种子 """ logger.info('train val split') data = [(data_x, data_y) for data_x, data_y in zip(X, y)] N = len(data) test_size = int(N * valid_size) if shuffle: random.seed(random_state) random.shuffle(data) valid = data[:test_size] train = data[test_size:] return train, validdef text2id(word2id, maxlen=None, valid_size=0.3, random_state=2018, shuffle=True, is_debug=False): """ 训练集文本转ID :param valid_size: 验证集大小 """ print(os.path.join(config.ROOT_DIR, config.TRAIN_FILE)) if len(glob(os.path.join(config.ROOT_DIR, config.TRAIN_FILE))) &gt; 0: logger.info('Text to id file existed') return logger.info('Text to id') sentences, labels, lengths = [], [], [] size = 0 with open(os.path.join(config.ROOT_DIR, config.RAW_DATA), 'r') as fr: for line in tqdm(fr, desc='text_to_id'): words, label = sent_label_split(line) sent = [word_to_id(word=word, word2id=word2id) for word in words] if maxlen: sent = sent[:maxlen] length = len(sent) sentences.append(sent) labels.append(label) lengths.append(length) size += 1 if is_debug: limit_train_size = 10000 if size &gt; limit_train_size: break train, valid = train_val_split(sentences, labels, valid_size=valid_size, random_state=random_state, shuffle=shuffle) del sentences, labels, lengths with open(config.TRAIN_FILE, 'w') as fw: for sent, label in train: sent = [str(s) for s in sent] line = "\t".join[str(label), " ".join(sent)] fw.write(line + '\n') logger.info('Writing train to file done') with open(config.VALID_FILE, 'w') as fw: for sent, label in train: sent = [str(s) for s in sent] line = "\t".join[str(label), " ".join(sent)] fw.write(line + '\n') logger.info('Writing valid to file done')# 功能整合，提供给外部调用的函数接口def data_helper(vocab_size, min_freq=3, stop_list=None, valid_size=0.3, random_state=2018, shuffle=True, is_debug=False): # 判断文件是否已存在 if len(glob(os.path.join(config.ROOT_DIR, config.WORD2ID_FILE))) &gt; 0: logger.info('Word to id file existed') with open(os.path.join(config.ROOT_DIR, config.WORD2ID_FILE), 'rb') as fr: word2id = pickle.load(fr) else: word2id = bulid_vocab(vocab_size=vocab_size, min_freq=min_freq, stop_word_list=stop_list, is_debug=is_debug) text2id(word2id, valid_size=valid_size, random_state=random_state, shuffle=shuffle, is_debug=is_debug) config.py 12345678# ---------PATH------------ROOT_DIR = '/home/daizelin/pytorch/'RAW_DATA = 'data/data_for_test.csv'TRAIN_FILE = 'outputs/intermediate/train.tsv'VALID_FILE = 'outputs/intermediate/valid.tsv'LOG_PATH = 'outputs/logs'is_debug = Falseflag_words = ['&lt;pad&gt;', '&lt;unk&gt;'] Logginger.py 12345678910111213141516171819202122232425262728293031323334353637383940414243import loggingfrom logging import Loggerfrom logging.handlers import TimedRotatingFileHandler'''使用方式from you_logging_filename.py import init_loggerlogger = init_logger("dataset",logging_path='')def you_function(): logger.info() logger.error()''''''日志模块1. 同时将日志打印到屏幕跟文件中2. 默认值保留近7天日志文件'''def init_logger(logger_name, logging_path): if logger_name not in Logger.manager.loggerDict: logger = logging.getLogger(logger_name) logger.setLevel(logging.DEBUG) handler = TimedRotatingFileHandler(filename=logging_path+"/all.log",when='D',backupCount = 7) datefmt = '%Y-%m-%d %H:%M:%S' format_str = '[%(asctime)s]: %(name)s %(filename)s[line:%(lineno)s] %(levelname)s %(message)s' formatter = logging.Formatter(format_str,datefmt) handler.setFormatter(formatter) handler.setLevel(logging.INFO) logger.addHandler(handler) console= logging.StreamHandler() console.setLevel(logging.INFO) console.setFormatter(formatter) logger.addHandler(console) handler = TimedRotatingFileHandler(filename=logging_path+"/error.log",when='D',backupCount=7) datefmt = '%Y-%m-%d %H:%M:%S' format_str = '[%(asctime)s]: %(name)s %(filename)s[line:%(lineno)s] %(levelname)s %(message)s' formatter = logging.Formatter(format_str,datefmt) handler.setFormatter(formatter) handler.setLevel(logging.ERROR) logger.addHandler(handler) logger = logging.getLogger(logger_name) return logger]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>文本预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[torchtext读取文本数据集]]></title>
    <url>%2F2018%2F11%2F28%2Ftorchtext%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Introduction本文主要介绍如何使用Torchtext读取文本数据集。 Torchtext是非官方的、一种为pytorch提供文本数据处理能力的库， 类似于图像处理库Torchvision。 Install 下载地址：https://github.com/text 安装：pip install text-master.zip 测试安装是否成功： import torchtext How To Use概览 先上一张图。使用tortext的目的是将文本转换成Batch，方便后面训练模型时使用。过程如下: 使用Field对象进行文本预处理， 生成example 使用Dataset类生成数据集dataset 使用Iterator生成迭代器 从图中还可以看到，torchtext可以生成词典vocab和词向量embedding，但个人比较喜欢将这两步放在数据预处理和模型里面进行，所以这两个功能不在本文之列。 常用的类12from torchtext.data import Field, Example, TabularDatasetfrom torchtext.data import BucketIterator Field：用来定义字段以及文本预处理方法 Example: 用来表示一个样本，通常为“数据+标签” TabularDataset: 用来从文件中读取数据，生成Dataset， Dataset是Example实例的集合 BucketIterator：迭代器，用来生成batch， 类似的有Iterator，Buckeiterator的功能较强大点，支持排序，动态padding等 数据准备见我上篇博文&lt;文本预处理&gt;。使用生成的train.tsv和valid.tsv。 使用步骤创建Field对象123456789101112131415def x_tokenize(x): # 如果加载进来的是已经转成id的文本 # 此处必须将字符串转换成整型 # 否则必须将use_vocab设为True return [int(c) for c in x.split()]def y_tokenize(y): return int(y)TEXT = Field(sequential=True, tokenize=x_tokenize, use_vocab=False, batch_first=True, fix_length=self.fix_length, eos_token=None, init_token=None, include_lengths=True, pad_token=0)LABEL = Field(sequential=False, tokenize=y_tokenize, use_vocab=False, batch_first=True) 参数说明 sequential 类型boolean, 作用：是否为序列，一般文本都为True，标签为False tokenize 类型: function， 作用: 文本处理，默认为str.split(), 这里对x和y分别自定义了处理函数。 use_vocab： 类型: boolean， 作用：是否建立词典 batch_first：类型: boolean， 作用：为True则返回Batch维度为(batch_size， 文本长度), False 则相反 fix_length：类型: int, 作用：固定文本的长度，长则截断，短则padding，可认为是静态padding；为None则按每个Batch内的最大长度进行动态padding。 eos_token：类型：str, 作用: 句子结束字符 init_token：类型：str, 作用: 句子开始字符 include_lengths：类型: boolean， 作用：是否返回句子的原始长度，一般为True，方便RNN使用。 pad_token：padding的字符，默认为”“, 这里因为原始数据已经转成了int类型，所以使用0。注意这里的pad_token要和你的词典vocab里的“”的Id保持一致，否则会影响后面词向量的读取。 读取文件生成数据集12345678910fields = [ ("label", LABEL), ("text", TEXT)]train, valid = TabularDataset.splits( path=config.ROOT_DIR, train=self.train_path, validation=self.valid_path, format='tsv', skip_header=False, fields=fields)return train, valid 生成迭代器123456train_iter, val_iter = BucketIterator.splits((train, valid), batch_sizes=(self.batch_size, self.batch_size), device = torch.device("cpu"), sort_key=lambda x: len(x.text), # field sorted by len sort_within_batch=True, repeat=False) 这里要注意的是sort_with_batch要设置为True，并指定排序的key为文本长度，方便后面pytorch RNN进行pack和pad。 我们来看下train_iter和val_iter里放了什么东西。 12345678bi = BatchIterator(config.TRAIN_FILE, config.VALID_FILE, batch_size=1, fix_length=None)train, valid = bi.create_dataset()train_iter, valid_iter = bi.get_iterator(train, valid)batch = next(iter(train_iter))print(train_iter)print('batch:\n', batch)print('batch_text:\n', batch.text)print('batch_label:\n', batch.label) 结果为： 123456789101112131415161718192021&lt;torchtext.data.iterator.BucketIterator object at 0x7f04a9d845f8&gt;batch:[torchtext.data.batch.Batch of size 1] [.label]:[torch.LongTensor of size 1] [.text]:('[torch.LongTensor of size 1x125]', '[torch.LongTensor of size 1]')batch_text: (tensor([[11149, 7772, 13752, 13743, 13773, 13793, 13791, 13591, 12478, 13759, 13783, 13492, 13793, 13745, 13754, 13612, 7452, 12185, 13789, 13784, 13765, 12451, 12112, 13620, 12240, 13073, 13790, 13738, 13637, 13759, 13776, 13793, 13739, 13783, 13787, 13793, 12702, 13790, 13698, 13774, 13792, 13768, 13715, 13641, 13761, 13713, 13682, 13712, 13786, 13749, 13097, 13734, 13702, 13735, 13257, 13642, 13700, 13793, 13684, 13755, 13488, 13789, 13750, 13484, 13494, 13793, 13624, 13670, 13786, 13655, 13768, 13687, 13774, 13792, 13791, 13591, 13546, 13777, 13658, 13740, 13577, 13790, 13684, 13755, 13793, 13572, 12891, 13793, 13368, 13713, 13682, 13712, 13786, 13786, 13642, 13700, 13793, 13429, 13520, 13613, 13792, 13368, 13790, 13750, 13699, 13764, 13590, 13675, 13742, 13691, 13688, 13742, 13782, 13538, 13742, 13783, 13787, 13774, 13645, 13742, 13791, 13740, 13744, 13750, 13792]]), tensor([125]))batch_label: tensor([11]) 可以看到batch有两个属性，分别为label和text, text是一个元组，第一个元素为文本，第二个元素为文本原始长度（这里因为我们在定义TEXT时使用了include_lengths=True，否则这里只返回文本）， label则是标签。 这里为了方便展示只使用了一个batch，返回的batch维度为（batch_size * length）, 数据格式为LongTensor。如果想看动态padding的效果，可多取几个batch，会发现他们是按照长度进行排序，并且是以0进行padding的。 对Batch包装一下，方便调用通过以上步骤，我们能够得到一个batch。但是很快就发现有个不太方便的地方。我们只能通过batch的属性，即自定义的字段名称，如text和label，来访问数据。这样的话在训练时我们只能这样操作： 123456for e in range(num_epoch): for batch in train_iter: inputs = batch.text[0] label = batch.label length = batch.text[1] pass 万一这个字段改了，还要去改训练的代码，很麻烦，关键是显得很LOW，姿势不对。 怎么办呢？ 我们对获得的iter进行包装一下，就可以避免这个问题了。 1234567891011121314151617181920class BatchWrapper(object): """对batch做个包装，方便调用，可选择性使用""" def __init__(self, dl, x_var, y_vars): self.dl, self.x_var, self.y_vars = dl, x_var, y_vars def __iter__(self): for batch in self.dl: x = getattr(batch, self.x_var) if self.y_vars is not None: temp = [getattr(batch, feat).unsqueeze(1) for feat in self.y_vars] label = torch.cat(temp, dim=1).long() else: raise ValueError('BatchWrapper: invalid label') text = x[0] length = x[1] yield (text, label, length) def __len__(self): return len(self.dl) 我们这样使用： 12train_iter = BatchWrapper(train_iter, x_var=self.x_var, y_vars=self.y_vars)val_iter = BatchWrapper(val_iter, x_var=self.x_var, y_vars=self.y_vars) 这样你就会发现batch不再有text和label属性了，而是一个三元组（text， label， length），调用时 就可以采用如下优雅一点的姿势： 123for e in range(num_epoch): for inputs, label, length in train_iter: pass 完整代码data_loader.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596"""将id格式的输入转换成dataset，并做动态padding"""import torchfrom torchtext.data import Field, TabularDatasetfrom torchtext.data import BucketIteratorimport configdef x_tokenize(x): # 如果加载进来的是已经转成id的文本 # 此处必须将字符串转换成整型 return [int(c) for c in x.split()]def y_tokenize(y): return int(y)class BatchIterator(object): def __init__(self, train_path, valid_path, batch_size, fix_length=None, x_var="text", y_var=["label"], format='tsv'): self.train_path = train_path self.valid_path = valid_path self.batch_size = batch_size self.fix_length = fix_length self.format = format self.x_var = x_var self.y_vars = y_var def create_dataset(self): TEXT = Field(sequential=True, tokenize=x_tokenize, use_vocab=False, batch_first=True, fix_length=self.fix_length, # 如需静态padding,则设置fix_length, 但要注意要大于文本最大长度 eos_token=None, init_token=None, include_lengths=True, pad_token=0) LABEL = Field(sequential=False, tokenize=y_tokenize, use_vocab=False, batch_first=True) fields = [ ("label", LABEL), ("text", TEXT)] train, valid = TabularDataset.splits( path=config.ROOT_DIR, train=self.train_path, validation=self.valid_path, format='tsv', skip_header=False, fields=fields) return train, valid def get_iterator(self, train, valid): train_iter, val_iter = BucketIterator.splits((train, valid), batch_sizes=(self.batch_size, self.batch_size), device = torch.device("cpu"), sort_key=lambda x: len(x.text), # field sorted by len sort_within_batch=True, repeat=False) train_iter = BatchWrapper(train_iter, x_var=self.x_var, y_vars=self.y_vars) val_iter = BatchWrapper(val_iter, x_var=self.x_var, y_vars=self.y_vars) ### batch = iter(train_iter) ### batch： ((text, length), y) return train_iter, val_iterclass BatchWrapper(object): """对batch做个包装，方便调用，可选择性使用""" def __init__(self, dl, x_var, y_vars): self.dl, self.x_var, self.y_vars = dl, x_var, y_vars def __iter__(self): for batch in self.dl: x = getattr(batch, self.x_var) if self.y_vars is not None: temp = [getattr(batch, feat).unsqueeze(1) for feat in self.y_vars] y = torch.cat(temp, dim=1).long() else: raise ValueError('BatchWrapper: invalid label') text = x[0] length = x[1] yield (text, y, length) def __len__(self): return len(self.dl) if __name__ == '__main__': bi = BatchIterator(config.TRAIN_FILE, config.VALID_FILE, batch_size=1, fix_length=None) train, valid = bi.create_dataset() train_iter, valid_iter = bi.get_iterator(train, valid) batch = next(iter(train_iter)) print(train_iter) print('batch:\n', batch) print('batch_text:\n', batch.text) print('batch_label:\n', batch.label) config.py 12TRAIN_FILE = 'outputs/intermediate/train.tsv'VALID_FILE = 'outputs/intermediate/valid.tsv']]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>torchtext，pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周期性学习率(Cyclical Learning Rate)技术]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%91%A8%E6%9C%9F%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%8E%87%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[本文介绍神经网络训练中的周期性学习率技术。 Introduction学习率(learning_rate, LR)是神经网络训练过程中最重要的超参数之一，它对于快速、高效地训练神经网络至关重要。简单来说，LR决定了我们当前的权重参数朝着降低损失的方向上改变多少。 1new_weight = exsiting_weight - learning_rate * gradient Fig.: A simple neural network where the w’s and b’s are to be learnt (Img Credit: Matt Mazur) 这看上去很简单。但是正如许多研究显示的那样，单单通过提升这一步就会对我们的训练产生深远的影响，并且尚有很大的优化空间。 本文介绍了一种叫做周期性学习率（CLR）的技术，它是一种非常新的、简单的想法，用来设置和控制训练过程中LR的大小。该技术在jeremyphoward今年的fast.ai course课程中提及过。 Motivation神经网络用来完成某项任务需要对大量参数进行训练。参数训练意味着寻找合适的一些参数，使得在每个batch训练完成后损失（loss）达到最小，而参数更新的方式则与LR密切相关。 通常来说，有两种广泛使用的方法用来设置训练过程中的LR。 One LR for all parameters一个典型的例子是SGD， 在训练开始时设置一个LR常量，并且设定一个LR衰减策略（如step，exponential等）。这个单一的LR用来更新所有的参数。在每个epochs中，LR按预先设定随时间逐渐衰减，当我们临近最小损失时， 通过衰减可以减缓更新，以防止我们越过最小值。 Fig. Effect of various learning rates on convergence (Img Credit: cs231n) 该方法存在如下挑战(refer)： 难以选择初始的LR达到想要的效果（如上图所示）； LR衰减策略同样难以设定，他们很难自适应动态变化的数据； 所有的参数使用相同的LR进行更新，而这些参数可能学习速率不完全相同； 很容易陷入马鞍点不能自拔 Adaptive LR for each parameter一些改进的优化器如AdaGrad, AdaDelta, RMSprop and Adam 很大程度上缓解了上述困难，方法是对每个参数采用不同的自适应学习率。比如AdaDelta，它的更新机制甚至不需要我们主动设置默认的学习率。 Fig: Animation comparing optimization algorithms (Img Credit: Alec Radford) Cycling Learning RateCLR是Leslie Smith于2015年提出的。这是一种调节LR的方法，在该方法中，设定一个LR上限和下限，LR的值在上限和下限的区间里周期性地变化。看上去，LCR似乎是自适应LR技术和SGD的竞争者，事实上，CLR技术是可以和上述提到的改进的优化器一起使用来进行参数更新的。 而在计算上，CLR比上述提到的改进的优化器更容易实现，正如文献[1]所述： Adaptive learning rates are fundamentally different from CLR policies, and CLR can be combined with adaptive learning rates, as shown in Section 4.1. In addition, CLR policies are computationally simpler than adaptive learning rates. CLR is likely most similar to the SGDR method that appeared recently. Why it works直觉上看，随着训练进度的增加我们应该保持学习率一直减小以便于在某一时刻达到收敛。 然而，事实恰与直觉相反，使用一个在给定区间里周期性变化的LR可能更有用处。原因是周期性高的学习率能够使模型跳出在训练过程中遇到的局部最低点和马鞍点。事实上，Dauphin等[3]指出相比于局部最低点，马鞍点更加阻碍收敛。如果马鞍点正好发生在一个巧妙的平衡点，小的学习率通常不能产生足够大的梯度改变使其跳过该点（即使跳过，也需要花费很长时间）。这正是周期性高学习率的作用所在，它能够更快地跳过马鞍点。 Fig.: A saddle point in the error surface (Img Credit: safaribooksonline) 另外一个好处是，最优的LR肯定落在最小值和最大值之间。换言之，我们确实在迭代过程中使用了最好的LR。 Epoch，iterations, cycles and stepsize首先介绍几个术语，理解这些术语可以更好地理解下面描述的算法和公式。 我们现在考虑一个包含50000个样本的训练集。 一个epoch是至将整个训练集训练一轮。如果我们将batch_size, 我们在一个epoch里会得到500个batch或者叫iteration。iteration的数目随着epoch的增加不断积累，在第二个epoch，对应着501到1000次iteration，后面的以此类推。 一个cycle定义为学习率从低到高，然后从高到低走一轮所用的iteration数。而stepsize指的是cycle迭代步数的一半。注意，cycle不一定必须和epoch相同，但实践上通常将cycle和epoch对应相同的iteration。 Fig: Triangular LR policy. (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 在上图中，两条红线分别表示学习率最小值（base lr）和学习率最大值（max lr）。蓝色的线是学习率随着iteration改变的方式。蓝线上下一次表示一个cycle，stepsize则是其一半。 Calculating the LR综上所述，接下来我们需要参数作为该算法的输入： stepsize base_lr max_lr 下面是LR更新的一段代码。 123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltdef get_triangular_lr(iteration, stepsize, base_lr, max_lr): """ Given the inputs, calculates the lr that should be applicable for this iteration """ cycle = np.floor(1 + iteration/(2 * stepsize)) x = np.abs(iteration/stepsize - 2 * cycle + 1) lr = base_lr + (max_lr - base_lr) * np.maximum(0, (1-x)) return lrif __name__ == '__main__': # Demo of how the LR varies with iterations num_iterations = 10000 stepsize = 1000 base_lr = 0.0001 max_lr = 0.001 lr_trend = list() for iteration in range(num_iterations): lr = get_triangular_lr(iteration, stepsize, base_lr, max_lr) # Update your optimizer to use this learning rate in this iteration lr_trend.append(lr) plt.plot(lr_trend) plt.show() 结果如下图所示。 Fig: Graph showing the variation of lr with iteration. We are using the triangular profile. Deriving the optimal base lr and max lr对于给定的数据集，怎么确定合理的base lr 和max lr呢？ 答案是先跑几个epoch，并且让学习率线性增加，观察准确率的变化，从中选出合适的base 和max lr。 我们让学习率按照上面的斜率进行增长，跑了几轮，结果如下图所示。 Fig: Plot of accuracy vs learning rate (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 可以看出，开始的时候，准确率随着学习率的增加而增加，然后进入平缓起期，然后又开始减小，出现震荡。注意图中准确率开始增长的那一点和达到平衡的那一点（图中红色箭头所示）。这两个点可以作为比较好的base lr 和 max lr。当然，你也可以选择平衡点旁边的准确率峰值点作为max lr， 把base lr 设为其1/3 或者1/4。 好了，三个参数中已经有两个确定了，那么怎么确定stepsize呢？ 已经有论文做过实验，他们将stepsize设成一个epoch包含的iteration数量的2-10倍。拿我们之前举的例子来说，我们一个epoch包含500个iteration，那么stepsize就设成1000-5000。该论文实验表明，stepsize设成2倍或者10倍，两者结果并没有太大的不同。 Variants上面我们实现的算法中，学习率是按照三角的规律周期性变化。除了这种以外，还有其他几种不同的函数形式。 traiangular2：这里max lr 按cycle进行对半衰减。 Fig: Graph showing the variation of lr with iteration for the triangular2 approach (Img Credit: Brad Kenstler) exp_range：这里max lr按iteration进行指数衰减。 Fig: Graph showing the variation of lr with iteration for the exp-range approach (Img Credit: Brad Kenstler) 这些与固定学习率的指数衰减（exponential decay）相比，有论文表明效果都得到了明显的提升。 Results如下图所示，在某神经网络上，CLR提供了一个快速的收敛，因此它的确值得一试。 Fig. CLR tested on CIFAR 10 (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 在上图的试验中，CLR花了25K次迭代达到了81%的准确率，传统的LR更新方法大约需要70K才能达到同样的水平。 Fig. CLR used with Nesterov and Adam. Much faster convergence with Nesterov (Nesterov is an improvement over SGD) (Img Credit: https://arxiv.org/pdf/1506.01186.pdf) 在另一项试验中，如上图所示，CLR + Nesterov优化器比著名的Adam收敛的还要快。 ConclusionCLR带来了一种新的方案来控制学习率的更新，它可以与SGD以及一些更加高级的优化器上一起使用。CLR应该成为每一个深度学习实践者工具箱里的一项技术。 References Cyclical Learning Rates for Training Neural Networks, Smith An overview of gradient descent optimization algorithms, Rudder Y. N. Dauphin, H. de Vries, J. Chung, and Y. Bengio. Rmsprop and equilibrated adaptive learning rates for non-convex optimization. SGDR: Stochastic Gradient Descent with Warm Restarts, Loshchilov, Hutter https://github.com/bckenstler/CLR]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>超参数</tag>
        <tag>学习率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像数据-TFrecord在动态图中的使用]]></title>
    <url>%2F2018%2F10%2F27%2FTFrecord%E5%9C%A8%E5%8A%A8%E6%80%81%E5%9B%BE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍图片数据使用TFrecord和tf.data.dataset进行存储和读取。 Tensorflow 提供了四种数据读取方式： Preloaded data: 用一个tf.constant常量将数据集加载进来，主要用于很小的数据集； Feeding: 使用python代码供给数据，将所有数据加载进内存，然后一个batch一个batch地输入到计算图中， 适用于小数据集； QueueRunner: 基于队列的输入通道，读取TFrecord静态图使用； tf.data API: 能够从不同的输入或文件格式中读取、预处理数据，并且对数据应用一些变换（例如，batching、shuffling、mapping function over the dataset），tf.data API 是旧的 feeding、QueueRunner的升级。值得注意的是， Eager模式必须使用该API来构建输入通道， 一般结合TFrecord使用。该API相比于Queue更容易使用。 What‘s TFrecordTFrecord是Tensorflow提供的一种二进制存储格式，可将数据和标签统一存储。从上述读取方式中可以看出，TFrecord在QueueRunner和tf.data API读取中均扮演了重要的角色。 Why TFrecord与其他方案相比， 使用TFrecord读取的优点在于： 可处理大规模数据量，而不会造成其他方案所带来的内存不够用的问题； 在Feeding方案中，batch读取的IO操作势必会阻塞训练，前一个batch加载完成后，神经网络必须等待下一个batch加载完成后才能继续训练，效率较低。 How To UseTFrecord的使用主要有两块：一是图片数据转TFrecord格式存储，二是解析存储好的TFrecord文件。下面逐一介绍。 图片转TFrecord本文使用的数据集是Kaggle猫狗数据集。 该数据集包含train和test两个文件夹， 分别为训练集和测试集，下面以train集为例操作。 123ls |wc -w25000 训练集包含25000张图片，猫狗各一半。 1234$ ls cat.124.jpg cat.3750.jpg cat.6250.jpg cat.8751.jpg dog.11250.jpg dog.2500.jpg dog.5000.jpg dog.7501.jpg... 图片文件以jpg格式存储，以cat， dog作为文件名开头。 1234567891011121314151617181920212223242526272829303132333435363738394041import osfrom tqdm import tqdmimport tensorflow as tfdef img_tfrecord_encode(classes, tfrecord_filename, data_path, is_training=True): """ 功能：读取图片转换成tfrecord格式的文件 @params: classes: 标签类别 @type：classes: dict @params: tfrecord_filename: tfrecord文件保存文件 @type：tfrecord_filename: str @params: data_path: 原始训练集存储路径 @is_training: 是否为训练集，用来区分训练集和测试集 """ # 初始化一个writer writer = tf.python_io.TFRecordWriter(tfrecord_filename) for img_name in tqdm(os.listdir(path)): name = img_name.split('.')[0] # 使用tf.gfile.FastFile读取图片要比PIL.Image读取处理得到的 # 最终TFrecod文件小得多，在本案例中，IMAGE方式读取得到的TFrecord大小约为3.7G # 而tf.gfile.FastFile得到的约为548M with tf.gfile.FastGFile(os.path.join(path, img_name), 'rb') as gf: img = gf.read() if is_training: # 构造特征 feature = &#123; 'label': tf.train.Feature(int64_list=tf.train.Int64List(value=[classes[name]])), 'img_raw': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img])), 'file_name': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_name.encode()])) &#125; else: feature = &#123; 'label': tf.train.Feature(int64_list=tf.train.Int64List(value=[-1])), 'img_raw':tf.train.Feature(bytes_list=tf.train.BytesList(value=[img])), 'file_name': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_name.encode()])) &#125; # example 对象将label和image特征进行封装 example = tf.train.Example(features=tf.train.Features(feature=feature)) writer.write(example.SerializeToString()) # 序列化为字符串 writer.close() print('tfrecord writen done!') 调用上述函数，可得到猫狗训练集的TFrecord格式文件 12345if __name__ == '__main__': classes = &#123;'cat': 0, 'dog': 1&#125; tfrecord_filename = 'cat_and_dog.tfrecord' data_path = 'train/' img_tfrecord_encode(classes, tfrecord_filename, data_path, is_training=True) 上述程序运行大约需要2min。 使用tf.data读取TFrecord在动态图（eager）模式下，QueueRunner不可用，必须使用tf.data进行TFrecord的读取。 12345678910111213141516171819202122232425262728293031323334353637383940def img_tfrecord_parse(tfrecord_filename, epochs, batch_size, shape, padded_shapes=None, shuffle=True, buffer_size=1000): """ @param: tfrecord_filename:tfrecord文件列表 @type:list @param: epoch:训练轮数（repeating次数） @type:int @param：batch_size:批数据大小 @type:int @param: shape:图片维度 @type:tuple @param: padded_shapes:不定长padding @type:tuple @param: shuffle:是否打乱 @type:boolean """ # 解析单个example，特征与encode一一对应。 def parse_example(serialized_example): features = tf.parse_single_example(serialized_example, features=&#123; 'label': tf.FixedLenFeature([], tf.int64), 'img_raw': tf.FixedLenFeature([], tf.string), 'file_name': tf.FixedLenFeature([], tf.string) &#125;) # 解码 image = tf.image.decode_jpeg(features['img_raw']) # 设置shape image = tf.image.resize_images(image, shape, method=1) label = tf.cast(features['label'], tf.int64) file_name = tf.cast(features['file_name'], tf.string) return image, label, file_name # 解析TFrecord dataset = tf.data.TFRecordDataset(tfrecord_filename).map(parse_example) if shuffle: if padded_shapes: dataset = dataset.repeat(epochs).shuffle(buffer_size=buffer_size).padded_batch(batch_size, padded_shapes) else: dataset = dataset.repeat(epochs).shuffle(buffer_size=buffer_size).batch(batch_size) else: if padded_shapes: dataset = dataset.repeat(epochs).padded_batch(batch_size, padded_shapes) else: dataset = dataset.repeat(epochs).batch(batch_size) return dataset 调用上述函数，解析TFrecord得到dataset。 123456789101112131415if __name__ == '__main__'(): tfrecord_filename = 'cat_and_dog.tfrecord' epochs = 100 batch_size = 64 shape = (227, 227) dataset = img_tfrecord_parse(tfrecord_filename=tfrecord_filename, epochs=epochs, batch_size=batch_size, shape=shape) # 查看dataset iterator = dataset.make_one_hot_iterator() image, label, file_name = iterator.get_next() print(image[0]) print(label[0]) print(file_name[0])]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
</search>
